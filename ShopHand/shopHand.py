'''
ShopHand: 
This file holds all the functions that the interface script interacts with to ensure
that the user gets the data they want. 
MODULES USED
sqlite3: used for the database
tkinter: used for the confirmation boxes
pickle: used to save the jobID and allow the jobID to constantly be a unique key
os: used to find the desktop path for exporting report files
datetime: finds the current date to find default for startDate and endDate
Author: Breann Thiessen
'''
import sqlite3 
from tkinter import * 
import pickle 
import os 
from datetime import date 
from shopHandErrors import * #holds the error box scripts from the .py file

#jobs to be chosen from
jobs = ["Brakes", "Head Lights", "Oil Change", "Tail Lights", "U-Joints", "Wheel Bearings"]
chosenJob = None #holds the job chosen
chosenUnits = [] #holds all units
startDate = str(date.today()) #holds the start date for repair report
endDate = str(date.today()) #holds the end date for repair report

#--------------------------------------------VARIABLE FUNCTIONS--------------------------------------------#
#will add the unit to the chosenUnits list or it will delete the unit from the list
#this depends on the interaction between the user and the checkboxes
def changeChosenUnits(unit):
    global chosenUnits
    if(unit not in chosenUnits):
        chosenUnits.append(unit)
    elif(unit in chosenUnits):
        chosenUnits.remove(unit)

#saves the job the user has picked
def saveJob(job):
    global chosenJob
    chosenJob = job

#sets the start date the user picked to generate a report
def setStartDate(date):
    global startDate
    startDate = str(date)

#sets the end date the picked to generate a report
def setEndDate(date):
    global endDate
    endDate = str(date)

#----------------------------------------------DB FUNCTIONS------------------------------------------------#

#resets the selections of the user after print is hit the confirmation window gets input
def clearChoices():
    global chosenJob
    global chosenUnits
    chosenJob = None
    chosenUnits.clear()

# checks the user entered in both a unit number and a job for the reapair job list
def errorCheck():
    global chosenJob
    global chosenUnits
    if(chosenJob == None and len(chosenUnits) <=0):
        jobListErr()
        clearChoices()

    elif(chosenJob == None):
        jobError()
        clearChoices()

    elif(len(chosenUnits) <= 0):
        unitError()
        clearChoices()

    else: 
        confirmJob(chosenJob, chosenUnits)

#checks that the report start date is not after the end date
def checkReport():
    global startDate
    global endDate
    if(startDate > endDate):
        dateError()
    else:
        confirmReport(startDate, endDate)
        
   
#Only called when error checks are performed The tool and parts list are 
#generated by querying the Sqlite3 database they are printed out for the user.
def getToolPart():
    global chosenJob
    global chosenUnits
    global jobID
    width = 21 #used to format the list
    #still need to generate a PDF
    desktop= os.path.join(os.environ['USERPROFILE'], 'Desktop', "Repair_Job.txt")
    list = open(desktop, "w+")
    for x in range(len(chosenUnits)):
        conn = sqlite3.connect("testShop.db")
        c = conn.cursor()
        list.write("UNIT %d: %s\n" % (chosenUnits[x], chosenJob))
        list.write("DATE   : %s \n\n" % str(date.today()))
        list.write("Tool Name             Quantity\n")
        #Get Tools Needed For Job
        c.execute('''SELECT Tool_List.Tool_name, Tool_List.Quantity
                         FROM Tool_List
                         WHERE Tool_List.Job_name = '%s' and Tool_List.VIN =
                         (SELECT Truck.VIN FROM Truck WHERE Unit_number = %d)
                         ''' % (chosenJob, chosenUnits[x]))
        y = c.fetchall()
        if(len(y) == 0):
            list.write("NO TOOLS\n")
        else:
            for i in range(len(y)):
                list.write("%s %d\n" %(y[i][0].ljust(width), y[i][1]))
        #insertJob(c, conn, chosenUnits[x]) 
        #Get the Parts Needed For Job
        list.write("\n\nPart Name             Part#             Quantity\n")
        c.execute('''SELECT P.Part_name, PL.Part_number, PL.Quantity
                         FROM Parts_List as PL, Part as P, Truck as T
                         WHERE PL.Part_number = P.Part_number and
                         PL.Job_name = '%s' and
                         T.VIN = PL.VIN and
                         PL.VIN =
                         (SELECT Truck.VIN
                          FROM Truck
                          WHERE Truck.Unit_number = %d)
                          ''' % (chosenJob, chosenUnits[x]))
        y = c.fetchall()
        if(len(y) == 0):
           list.write("NO PARTS\n")
        else:
            for i in range(len(y)):
                list.write("%s %s %d\n" %(y[i][0].ljust(width), y[i][1].ljust(width-4), y[i][2]))
        #Get Hours Needed For Job
        c.execute("SELECT Job.Time_needed FROM Job WHERE Job.Job_name = '%s'" %(chosenJob))
        y = c.fetchone()[0]
        list.write("\nHours Needed: %d\n\n\n".ljust(width) % (y))
        conn.close()
    list.close()
    
 
#this function is called when the user chooses to print a job list,
#when they choose to print the job list then the job is inserted into the
#database
def insertJob(c, conn, unit):
    global chosenJob
    fileIn = open("job.pickle", "rb")
    jobID = pickle.load(fileIn)
    print("Job ID %d" % jobID)
    fileIn.close()
    #get the VIN of the truck that will be worked on
    c.execute('''SELECT T.VIN
                 FROM Truck as T
                 WHERE T.Unit_number = %d
                 ''' % unit)
    #save that VIN so it can be inserted into the table
    vin = c.fetchone()[0]
    today = date.today()
    c.execute('''INSERT INTO Repair_Job VALUES('%d','%s','%s','%s')
              ''' % (jobID, str(today), chosenJob, vin))
    conn.commit()
    jobID = jobID + 1
    fileOut= open("job.pickle", "wb")
    pickle.dump(jobID, fileOut)
    fileOut.close()

#this function is called when the user requests to print a repair report
#the dates are used as a range to get the information from querying the database
#the results are printed out for the user
def getReport(): 
    global startDate
    global endDate
    shopCost = 95.0
    wage = 35.0
    desktop= os.path.join(os.environ['USERPROFILE'], 'Desktop', "Repair_Report.txt")
    report = open(desktop, "w+")
    report.write("REPAIR REPORT: %s to %s\n\n" %(startDate, endDate))
    conn = sqlite3.connect("testShop.db")
    c = conn.cursor() # used to find the jobs
    #query finds the date of the job, unit nnumber, job name, and hours to complete that job
    c.execute('''SELECT R.Date, T.Unit_number, R.Job_name, J.Time_needed
          FROM Repair_Job as R, Truck as T, Job as J
          WHERE R.VIN = T.VIN and R.Date >= '%s' and R.Date <= '%s' and R.Job_name = J.Job_name
       ''' %(startDate, endDate))      
    y = c.fetchall()
    if (len(y) > 0):
        report.write("Date               Unit               Job Name                Job Cost\n")
        totalCost = 0
        for x in range(len(y)):
           cost = (y[x][3] * shopCost) + (y[x][3] * wage)
           totalCost = totalCost + cost
           report.write("%s %s %s $%.2f\n" %(y[x][0].ljust(18), str(y[x][1]).ljust(18), y[x][2].ljust(23), cost))
        totalCost = "$%.2f" %(totalCost)
        report.write("\nTOTAL COST: %s" %(totalCost).rjust(58))
           
    else:
        report.write("NO DATA TO REPORT")
    conn.close()
    report.close()
     
#-----------------------------------------------------CONFIRMATION BOX----------------------------------------------------------------------- 

#confirms the job the user is generating a parts and tools list for
def confirmJob(job, units):
    root = Tk()
    root.geometry("500x200")

    ask = Label(root, text = "Press OK to Confirm the Following Jobs, Press Cancel to Abort", font = ("Arial", 12), fg = "black")
    ok = Button(root, text="OK", font = ("Arial", 12), command=lambda: [getToolPart(), clearChoices(), root.destroy()], fg = "black", width = 8)
    cancel = Button(root, text = "Cancel", font = ("Arial", 12), command=lambda: [clearChoices(), root.destroy()], fg = "black", width = 8)
    h = 50
    for x in range(len(units)):
        m = Label(root, text="Unit %d: %s"%(units[x], job), font = ("Arial", 10), fg = "black")
        m.place(x = 30, y = h)
        h = h + 20
    ask.place(x = 30, y = 30)
    ok.place(x = 153, y = 150)
    cancel.place(x = 253, y = 150)
    root.mainloop()

#confirms the report the user wants to generate for a repair report
def confirmReport(s, e):
    root = Tk()
    root.geometry("500x200")

    ask = Label(root, text = "Press OK to Confirm the Follow Report, Press Cancel to Abort", font = ("Arial", 12), fg = "black")
    ok = Button(root, text="OK", font = ("Arial", 12), command=lambda: [getReport(), root.destroy()], fg = "black", width = 8)
    cancel = Button(root, text = "Cancel", font = ("Arial", 12), command=lambda: [root.destroy()], fg = "black", width = 8)
    m = Label(root, text = "Report: %s to %s" %(s,e), fg = "black")
    m.place(x = 30, y = 55)
    ask.place(x = 30, y = 30)
    ok.place(x = 150, y = 120)
    cancel.place(x = 250, y = 120)
    root.mainloop()